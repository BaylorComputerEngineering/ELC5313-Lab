module instruction_queue(
input wire clock,
input wire issue_error,
input wire adder_available,
input wire [5:0] adder_RS_available,
input wire [5:0] RS_issued,
input wire [5:0] RS_executing_adder,
input wire adder_rts,
input wire [5:0] RS_finished,
output reg [5:0] operation,
output reg [2:0] execution_unit,
output reg [4:0] Dest_address, 
output reg [4:0] A_address, 
output reg [4:0] B_address,
output reg issue
);
 
parameter TRUE =1'b1;
parameter FALSE =1'b0;
parameter LAST_INSTRUCTION_ELEMENT = 1023;
parameter INSTRUCTION_ADDRESS_BITS = 10;
parameter LAST_QUEUE_ELEMENT = 3;
parameter QUEUE_ADDRESS_BITS = 3;
parameter CLEAR =0;
parameter OPCODE_HIGH      = 31;
parameter OPCODE_LOW       = 26;
parameter EXEC_UNIT_HIGH      = 31;
parameter EXEC_UNIT_LOW       = 29;
parameter SOURCE1_HIGH     = 25;
parameter SOURCE1_LOW      = 21;
parameter SOURCE2_HIGH     = 20;
parameter SOURCE2_LOW      = 16;
parameter DESTINATION_HIGH = 15;
parameter DESTINATION_LOW  = 11;
parameter BUSY_MASK = 4'b0001;
parameter ISSUE_MASK = 4'b0010;
parameter EXECUTE_MASK = 4'b0100;
parameter WRITE_BACK_MASK = 4'b1000;
parameter ADDER= 3'b000;
parameter alu_add = 3'b000;
parameter alu_sub = 3'b001;
parameter alu_or  = 3'b100;
parameter alu_and = 3'b101;
parameter alu_not = 3'b110;
parameter alu_xor = 3'b111;
 
integer i,j;
 
reg issued_this_clock = 0;
reg [31:0] Instruction_Memory [LAST_INSTRUCTION_ELEMENT:0];
reg [INSTRUCTION_ADDRESS_BITS:0] PC=0;
reg next_queue_location;
reg [31:0] Instruction [LAST_QUEUE_ELEMENT:0];
reg [5:0] RS_Holding [LAST_QUEUE_ELEMENT:0];
reg [3:0] Status [LAST_QUEUE_ELEMENT:0];
reg [QUEUE_ADDRESS_BITS-1:0] Queue_End = CLEAR;

initial
begin
    issue<=FALSE;
    for(i=0;i<=LAST_QUEUE_ELEMENT;i=i+1)
    begin
        Instruction[i] <= CLEAR;
        RS_Holding[i] <= CLEAR;
        Status[i] <= CLEAR;
    end

    Instruction_Memory[0] <= {alu_add , alu_add , 5'd5 , 5'd5, 5'd3, 11'b0};
    Instruction_Memory[1] <= {alu_sub , alu_sub , 5'd3 , 5'd13, 5'd20, 11'b0};
    Instruction_Memory[2] <= {alu_and , alu_and , 5'd15 ,  5'd18, 5'd21, 11'b0};
    Instruction_Memory[3] <= {alu_add , alu_add , 5'd25 ,  5'd30, 5'd22, 11'b0};

end
 
 
always@(posedge(clock))
begin
    if(Queue_End<=LAST_QUEUE_ELEMENT & PC<=LAST_INSTRUCTION_ELEMENT)
    begin
       Instruction[Queue_End]<=Instruction_Memory[PC];
       PC<=PC+1;
       Status[Queue_End]<=BUSY_MASK;
       Queue_End<=Queue_End+1;
   end

end
 
always@(posedge(clock))
begin
    if(adder_available)
    begin
       for(i=0;i<=LAST_QUEUE_ELEMENT;i=i+1)
       begin
          if(~issued_this_clock & 
             ~(| (Status[i] & ISSUE_MASK)) & 
             (| (Status[i] & BUSY_MASK)) )//SPP:& 
             //Instruction[i][EXEC_UNIT_HIGH:EXEC_UNIT_LOW]==ADDER) 
          begin
             operation <= Instruction[i][OPCODE_HIGH:OPCODE_LOW];
             execution_unit <= Instruction[i][EXEC_UNIT_HIGH:EXEC_UNIT_LOW];
             A_address <= Instruction[i][SOURCE1_HIGH:SOURCE1_LOW];
             B_address <= Instruction[i][SOURCE2_HIGH:SOURCE2_LOW];
             Dest_address <= Instruction[i][DESTINATION_HIGH:DESTINATION_LOW];
             RS_Holding[i] <= adder_RS_available;
             issue<=TRUE;
             issued_this_clock=TRUE;
          end
       end
    end
end
 

always@(RS_issued)
begin
    #1;
    for(i=0;i<=LAST_QUEUE_ELEMENT;i=i+1)
    begin
        if(RS_Holding[i]==RS_issued & RS_issued>0)
              if(~issue_error)
                 Status[i]=Status[i] | ISSUE_MASK;
    end
    issue<=FALSE;
    issued_this_clock<=FALSE;
end
 

always@(posedge(RS_executing_adder))
begin
    for(i=0;i<=LAST_QUEUE_ELEMENT;i=i+1)
    begin
        if(RS_Holding[i]==RS_executing_adder & RS_executing_adder>0)
           Status[i]=Status[i] | EXECUTE_MASK;
    end
end
 

always@(posedge(adder_rts))
begin
    for(i=0;i<=LAST_QUEUE_ELEMENT;i=i+1)
    begin
        if(RS_Holding[i]==RS_executing_adder & RS_executing_adder>0)
           Status[i]=Status[i] | WRITE_BACK_MASK;
    end
end
 
always@(RS_finished)
begin
    for(i=0;i<=LAST_QUEUE_ELEMENT;i=i+1)
    begin
        if(RS_Holding[i]== RS_finished & RS_finished>0)
        begin
           if(i!=LAST_QUEUE_ELEMENT)
                 for(j=i;j<LAST_QUEUE_ELEMENT;j=j+1)
                 begin  
                    Instruction[j] <= Instruction[j+1];
                    RS_Holding[j]  <= RS_Holding[j+1];
                    Status[j]      <= Status[j+1];
                 end
           Instruction[LAST_QUEUE_ELEMENT] <= CLEAR;
           RS_Holding[LAST_QUEUE_ELEMENT] <= CLEAR;
           Status[LAST_QUEUE_ELEMENT] <= CLEAR;
           Queue_End<=Queue_End-1;
       end         
    end
end
endmodule

 
