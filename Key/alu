module alu(
    input  logic clock, 
    input  logic issue,
    input  logic signed [31:0] A, B,
    input  logic A_invalid, B_invalid,
    input  logic [5:0] opcode,
    input  logic CDB_xmit,
    inout  logic signed [31:0] CDB_data,
    inout  logic [5:0] CDB_source,
    inout  logic CDB_write,
    output logic  CDB_rts,
    output logic available,
    output logic [5:0] RS_available,
    output logic  [5:0] issued,
    output logic [5:0] RS_executing,
    output logic  error
);

    parameter disconnected = 32'bz;
    
    parameter delay = 20;
    
    parameter update_delay = 5;
    
    parameter none = 2'b00;
    
    parameter valid = 6'b000000;
    
    parameter no_error = 1'b0;
    parameter all_rs_busy = 1'b1;
    
    parameter not_issued = 6'b000000;
    
    parameter not_busy = 1'b0;
    parameter in_use = 1'b1;
    
    parameter ready = 1'b1;
    parameter not_ready = 1'b0;
    
    parameter clear = 0;
    
    parameter no_rs = 6'b000000;
    parameter adder_1 = 6'b000001;
    parameter adder_2 = 6'b000010;
    parameter adder_3 = 6'b000011;
    
    parameter alu_add = 3'b000;
    parameter alu_sub = 3'b001;
    parameter alu_or  = 3'b100;
    parameter alu_and = 3'b101;
    parameter alu_not = 3'b110;
    parameter alu_xor = 3'b111;
   
    reg signed [31:0] CDB_data_out;
    reg [5:0] CDB_source_out;
    reg CDB_write_out;
    reg [5:0] operation [2:0];

    reg [5:0] Qj [2:0], Qk [2:0];

    reg signed [31:0] Vj [2:0], Vk [2:0];

    reg Busy [2:0]; 
    reg Unit_Busy;  
    reg [1:0] adder_calculating;   
    reg [5:0] RS_num_of [2:0];    
    reg [1:0] Priority_Station;   
    reg [1:0] Second_Station;     
    reg [1:0] Last_Station;
    wire [5:0] RS_availability_of_Second_or_Last, RS_availability_of_Last; 

    initial begin
        CDB_rts = not_ready;
        CDB_data_out = clear;
        CDB_source_out = no_rs;
        CDB_write_out = not_ready;
        Priority_Station = 0;
	    Second_Station = 1;
	    Last_Station = 2;
        Unit_Busy = not_busy;
        Busy[0] = not_busy;
        Busy[1] = not_busy;
        Busy[2] = not_busy;
        issued = not_issued;
        error = no_error;
        RS_num_of[0] = adder_1;
        RS_num_of[1] = adder_2;
        RS_num_of[2] = adder_3;
        adder_calculating = none;
    end

    assign available = ~(Busy[0] & Busy[1] & Busy[2]);
    assign RS_availability_of_Last = ~Busy[Last_Station] ? RS_num_of[Last_Station] : no_rs;
    assign RS_availability_of_Second_or_Last = ~Busy[Second_Station] ? RS_num_of[Second_Station] : RS_availability_of_Last;
    assign RS_available = ~Busy[Priority_Station] ? RS_num_of[Priority_Station] : RS_availability_of_Second_or_Last;

    assign RS_executing = Unit_Busy ? RS_num_of[adder_calculating] : no_rs;
    
    always @(negedge clock) begin
        if (issue) begin 
            if (~Busy[0]) begin
                operation[0] <= opcode;
                Busy[0] = in_use;
                if (A_invalid) begin
                    Qj[0] <= A;
                end else begin
                    Vj[0] <= A;
                    Qj[0] <= valid;
                end
                
                if (B_invalid) begin
                    Qk[0] <= B;
                end else begin
                    Vk[0] <= B;
                    Qk[0] <= valid;
                end
                issued <= RS_num_of[0];
                error <= no_error;
            end else if (~Busy[1]) begin
                operation[1] <= opcode;
                Busy[1] = in_use;
                if (A_invalid) begin
                    Qj[1] <= A;
                end else begin
                    Vj[1] <= A;
                    Qj[1] <= valid;
                end
                
                if (B_invalid) begin
                    Qk[1] <= B;
                end else begin
                    Vk[1] <= B;
                    Qk[1] <= valid;
                end
                issued <= RS_num_of[1];
                error <= no_error;
            end else if (~Busy[2]) begin
                operation[2] <= opcode;
                Busy[2] = in_use;
                if (A_invalid) begin
                    Qj[2] <= A;
                end else begin
                    Vj[2] <= A;
                    Qj[2] <= valid;
                end
                
                if (B_invalid) begin
                    Qk[2] <= B;
                end else begin
                    Vk[2] <= B;
                    Qk[2] <= valid;
                end
                issued <= RS_num_of[2];
                error <= no_error;
            end else begin
                issued <= not_issued; 
                error <= all_rs_busy;
            end
        end
             
       end

    always @(negedge clock) begin
        if (CDB_write) begin
            if (CDB_source == Qj[0]) begin
                Vj[0] <= CDB_data;
                Qj[0] <= valid;
            end
            if (CDB_source == Qk[0]) begin
                Vk[0] <= CDB_data;
                Qk[0] <= valid;
            end
            if (CDB_source == Qj[1]) begin
                Vj[1] <= CDB_data;
                Qj[1] <= valid;
            end
            if (CDB_source == Qk[1]) begin
                Vk[1] <= CDB_data;
                Qk[1] <= valid;
            end
            if (CDB_source == Qj[2]) begin
                Vj[2] <= CDB_data;
                Qj[2] <= valid;
            end
            if (CDB_source == Qk[2]) begin
                Vk[2] <= CDB_data;
                Qk[2] <= valid;
            end
        end
    end

    always @(posedge clock) begin
        if (Unit_Busy == not_busy) begin
            if (Busy[Priority_Station] == in_use && Qj[Priority_Station] == valid && Qk[Priority_Station] == valid) begin
                Unit_Busy = in_use;
                adder_calculating = Priority_Station;
                #delay;
                case (operation[Priority_Station])
                    alu_add: CDB_data_out = Vj[Priority_Station] + Vk[Priority_Station];
                    alu_sub: CDB_data_out = Vj[Priority_Station] - Vk[Priority_Station];
                    alu_or:  CDB_data_out = Vj[Priority_Station] | Vk[Priority_Station];
                    alu_and: CDB_data_out = Vj[Priority_Station] & Vk[Priority_Station];
                    alu_not: CDB_data_out = ~Vj[Priority_Station];
                    alu_xor: CDB_data_out = Vj[Priority_Station] ^ Vk[Priority_Station];
                endcase
                CDB_source_out = RS_num_of[Priority_Station];
                CDB_write_out = ready;
                CDB_rts = ready;
            end else if (Busy[Second_Station] == in_use && Qj[Second_Station] == valid && Qk[Second_Station] == valid) begin
                Unit_Busy = in_use;
                adder_calculating = Second_Station;
                #delay;
                case (operation[Second_Station])
                    alu_add: CDB_data_out = Vj[Second_Station] + Vk[Second_Station];
                    alu_sub: CDB_data_out = Vj[Second_Station] - Vk[Second_Station];
                    alu_or:  CDB_data_out = Vj[Second_Station] | Vk[Second_Station];
                    alu_and: CDB_data_out = Vj[Second_Station] & Vk[Second_Station];
                    alu_not: CDB_data_out = ~Vj[Second_Station];
                    alu_xor: CDB_data_out = Vj[Second_Station] ^ Vk[Second_Station];
                endcase
                CDB_source_out = RS_num_of[Second_Station];
                CDB_write_out = ready;
                CDB_rts = ready;
            end else if (Busy[Last_Station] == in_use && Qj[Last_Station] == valid && Qk[Last_Station] == valid) begin
                Unit_Busy = in_use;
                adder_calculating = Last_Station;
                #delay;
                case (operation[Last_Station])
                    alu_add: CDB_data_out = Vj[Last_Station] + Vk[Last_Station];
                    alu_sub: CDB_data_out = Vj[Last_Station] - Vk[Last_Station];
                    alu_or:  CDB_data_out = Vj[Last_Station] | Vk[Last_Station];
                    alu_and: CDB_data_out = Vj[Last_Station] & Vk[Last_Station];
                    alu_not: CDB_data_out = ~Vj[Last_Station];
                    alu_xor: CDB_data_out = Vj[Last_Station] ^ Vk[Last_Station];
                endcase
                CDB_source_out = RS_num_of[Last_Station];
                CDB_write_out = ready;
                CDB_rts = ready;
            end
        end
    end   

    assign CDB_data = CDB_xmit ? CDB_data_out : disconnected;
    assign CDB_source = CDB_xmit ? CDB_source_out : disconnected;
    assign CDB_write = CDB_xmit ? CDB_write_out : disconnected;


    always @(posedge clock) begin
        issued = not_issued;
        error = no_error;
    end
   
    always @(negedge CDB_xmit) begin
        CDB_rts = not_ready;
        CDB_write_out = not_ready;
        Unit_Busy = not_busy;
        Busy[adder_calculating] = not_busy;
        adder_calculating = none;
    end 


endmodule
